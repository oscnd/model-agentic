package main

import (
	"os"
	"strings"

	"github.com/bsthun/gut"
	"github.com/davecgh/go-spew/spew"
	"go.scnd.dev/open/model/agentic/package/agent"
	"go.scnd.dev/open/model/agentic/package/call"
	"go.scnd.dev/open/model/agentic/package/function"
)

func main() {
	// * initialize caller
	caller := call.NewOpenai(os.Getenv("OPENAI_BASE_URL"), os.Getenv("OPENAI_API_KEY"))
	model := os.Getenv("OPENAI_MODEL")

	// * create research agent
	researchAgent := agent.New(caller, &agent.Option{
		Name:                   gut.Ptr("research_agent"),
		Persona:                gut.Ptr("You are a research assistant. Your job is to gather information about specific topics and provide comprehensive summaries."),
		Description:            gut.Ptr("Research agent for gathering information"),
		AllowSubagentDispatch:  nil,
		SubagentDispatchPrompt: nil,
		SubagentDispatchLimit:  nil,
		FunctionOption: &function.Option{
			Model:       &model,
			MaxTokens:   gut.Ptr(1000),
			Temperature: gut.Ptr(0.7),
			CallOption: &call.Option{
				SchemaName:        gut.Ptr("research_agent_call"),
				SchemaDescription: gut.Ptr("Call schema for research agent"),
			},
		},
	})

	// * add web search function to research agent
	webSearchDeclaration := &function.Declaration{
		Name:        gut.Ptr("web_search"),
		Description: gut.Ptr("Search the web for information about a specific topic"),
		Argument: call.SchemaConvert(new(struct {
			Query string `json:"query" description:"The search query" validate:"required"`
		})),
		Func: func(arguments map[string]any) (map[string]any, *gut.ErrorInstance) {
			query := arguments["query"].(string)
			// * simulate web search with mock results
			results := []string{
				"Artificial Intelligence (AI) is a branch of computer science that aims to create intelligent machines capable of performing tasks that typically require human intelligence.",
				"Machine Learning (ML) is a subset of AI that enables systems to learn and improve from experience without being explicitly programmed.",
				"Deep Learning (DL) is a subset of machine learning that uses neural networks with multiple layers to analyze various forms of data.",
			}

			var result string
			for _, value := range results {
				if strings.Contains(strings.ToLower(value), strings.ToLower(query)) {
					result = value
					break
				}
			}

			if result == "" {
				result = "Found general information about: " + query
			}

			return map[string]any{
				"search_result": result,
			}, nil
		},
	}

	// * add search function to research agent
	researchAgent.AddFunction(webSearchDeclaration)

	// * create writer agent
	writerAgent := agent.New(caller, &agent.Option{
		Name:                   gut.Ptr("writer_agent"),
		Persona:                gut.Ptr("You are a technical writer. Your job is to take research information and create well-structured, informative content."),
		Description:            gut.Ptr("Writer agent for creating content from research"),
		AllowSubagentDispatch:  nil,
		SubagentDispatchPrompt: nil,
		SubagentDispatchLimit:  nil,
		FunctionOption: &function.Option{
			Model:       &model,
			MaxTokens:   gut.Ptr(1500),
			Temperature: gut.Ptr(0.8),
			CallOption:  new(call.Option),
		},
	})

	// * add format content function to writer agent
	formatContentDeclaration := &function.Declaration{
		Name:        gut.Ptr("format_content"),
		Description: gut.Ptr("Format content into a structured document"),
		Argument: call.SchemaConvert(new(struct {
			Content string `json:"content" description:"The content to format" validate:"required"`
			Format  string `json:"format" description:"The desired format (markdown, paragraph, bullet)" validate:"required"`
		})),
		Func: func(arguments map[string]any) (map[string]any, *gut.ErrorInstance) {
			content := arguments["content"].(string)
			format := arguments["format"].(string)

			var formattedContent string
			switch format {
			case "markdown":
				formattedContent = "# Research Summary\n\n" + content + "\n\n---\n\n*Generated by AI Agent*"
			case "bullet":
				lines := strings.Split(content, ". ")
				bullets := make([]string, 0)
				for _, line := range lines {
					if strings.TrimSpace(line) != "" {
						bullets = append(bullets, "- "+strings.TrimSpace(line))
					}
				}
				formattedContent = strings.Join(bullets, "\n")
			default:
				formattedContent = content
			}

			return map[string]any{
				"formatted_content": formattedContent,
			}, nil
		},
	}

	// * add format function to writer agent
	writerAgent.AddFunction(formatContentDeclaration)

	// * add writer as subagent to research agent
	researchAgent.AddSubagent(writerAgent)

	// * define the task
	task := "Research the topic of 'Artificial Intelligence' and create a comprehensive summary. First gather information using web search, then delegate to the writer agent to format the content properly."

	// * create agent state
	state := researchAgent.NewState(&task)

	// * track function invocations using callbacks
	var invocations []*function.CallbackBeforeFunctionCall
	var afterInvocations []*function.CallbackAfterFunctionCall

	state.FunctionState.OnBeforeFunctionCall = func(callback *function.CallbackBeforeFunctionCall) (map[string]any, *gut.ErrorInstance) {
		invocations = append(invocations, callback)
		return nil, nil
	}

	state.FunctionState.OnAfterFunctionCall = func(callback *function.CallbackAfterFunctionCall) (map[string]any, *gut.ErrorInstance) {
		afterInvocations = append(afterInvocations, callback)
		return nil, nil
	}

	// * call the research agent
	response, err := researchAgent.Call(state, nil)
	if err != nil {
		gut.Fatal("agent call failed", err)
	}

	// * display results
	spew.Dump("Agent Response:", response)
	spew.Dump("Function Invocations:", len(afterInvocations))

	// * show invocation details
	for i, invoke := range afterInvocations {
		println("\n--- Invocation", i+1, "---")
		println("Function:", *invoke.Declaration.Name)
		spew.Dump(invoke)
	}
}
